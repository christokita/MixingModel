{
    "contents" : "# \n# Utility Functions for Threshold Voter Models\n#\n\n# Required libraries\nrequire(igraph)\nrequire(msm)\nsource(\"scripts/__Util_ForceAtlas2.R\")\n\n# Seed state space\nseedState <- function(N) {\n  space <- c(0, 1)\n  state <- sample(space, N, replace = TRUE)\n  state <- as.matrix(state)\n  return(state)\n}\n\n# Seed thresholds\nseedThresholds <- function(N, Thresh1, Thresh2, ThreshSD) {\n  # Build empty matrix\n  out <- matrix(nrow = N, ncol = 2)\n  names(out) <- c(\"Threshold1\", \"Threshold2\")\n  # Sample from distribution\n  for (i in 1:N) {\n    out[i, 1] <- rtnorm(n = 1, mean = Thresh1, sd = ThreshSD, lower = 0, upper = 1)\n    out[i, 2] <- rtnorm(n = 1, mean = Thresh2, sd = ThreshSD, lower = 0, upper = 1)\n  }\n  return(out)\n}\n\n# Color graph\ncolorByState <- function(state) {\n  colorState <- lapply(state, function(st) {\n    col <- ifelse(st == 1, \"red\", \"blue\")\n  })\n  colorState <- unlist(colorState)\n  return(colorState)\n}\n\n# Calculate new state\ncalcNewState <- function(probState, state, pUpdate, thresh) {\n  newState <- lapply(1:length(probState), FUN = function(i) { \n    scanNeighbors <- sample(c(0, 1), 1, prob = c(1 - pUpdate, pUpdate)) #probability that ind will sample neighbors\n    if (scanNeighbors == 1) {\n      if((1 - probState[i]) > thresh[i, 1] & probState[i] > thresh[i, 2]) { #both thresholds met\n        st <- sample(c(0, 1), 1, prob = c(probState[i], 1 - probState[i])) #probability state change \n      } else if ((1 - probState[i]) > thresh[i, 1]) { #only task 1 threshold met\n        st <- 0\n      } else if(probState[i] > thresh[i, 2]) { #only task 2 threshold met\n        st <- 1\n      } else { #no thresholds met\n        st <- state[i] #keep same state\n      }\n    } else {\n      st <- state[i] #keep same state\n    }\n    return(st)\n  })\n  newState <- unlist(newState)\n  return(newState)\n}\n\n# Function\nsimulateThreshold <- function(N, gens, netPower, probOfUpdate, Thresh1, Thresh2, ThreshSD, folderName) {\n  \n  # Scale free network\n  g <- barabasi.game(n = N, m = 3, power = netPower, directed = FALSE)\n  layout <- layout.forceatlas2(g, \n                               iterations = 1000, \n                               k = 200, \n                               plotstep = 0)\n  gAdj <- as_adjacency_matrix(g)     \n  plot(g, \n       layout = layout, \n       vertex.label = NA,\n       vertex.size = 7)\n  \n  # Make matrix\n  adj <- as.matrix(gAdj)\n  \n  # State matrix\n  state <- seedState(N) #maybe start in more favorable task\n  \n  # Threshold matrix\n  thresh <- seedThresholds(N = N, Thresh1 = Thresh1, Thresh2 = Thresh2, ThreshSD = ThreshSD)\n  \n  # Get maximum for plotting purposes\n  histLim <- max(hist(thresh[,1], breaks = seq(0, 1, 0.05))$counts,\n                 hist(thresh[,2], breaks = seq(0, 1, 0.05))$counts)\n  \n  # Colors\n  colorState <- colorByState(state)\n  g_soc <- g %>% \n    set_vertex_attr(\"color\", value = colorState)\n  \n  # Quantify state of tasks\n  blue <- length(colorState[colorState == \"blue\"])/N\n  \n  # Quantify task switches\n  switchState <- rep(NA, gens + 1)\n  \n  # Create Folder to output plots\n  folderPath <- paste0(\"output/\", folderName)\n  dir.create(folderPath, showWarnings = FALSE)\n  \n  # plot\n  path <- paste0(folderPath, \"/Gen0\", \".jpg\")\n  png(filename = path, width = 600, height = 800, units = \"px\")\n  layout(matrix(c(1, 1, 1, 1, 1, 1, 2, 3, 4), nrow = 3, ncol = 3, byrow = TRUE))\n  plot(g_soc, \n       layout = layout, \n       vertex.label = NA,\n       vertex.size = 7,\n       vertex.color=V(g)$color)\n  hist(thresh[, 1], \n       breaks = seq(0, 1, 0.05), \n       col = rgb(0, 0, 1, 0.5),\n       ylab = NULL, \n       xlab = NULL,\n       main = \"Threshold Distribution\",\n       ylim = c(0, histLim))\n  hist(thresh[, 2],\n       col = rgb(1, 0, 0, 0.5),\n       breaks = seq(0, 1, 0.05), \n       add = TRUE)\n  plot(x = 0:gens, \n       y = c(blue, rep(NA, gens)), \n       pch = 20,\n       ylab = '',\n       xlab = \"Generation\",\n       ylim = c(0, 1), \n       main = \"Frequency of Task 1\")\n  lines(x = c(0, gens), \n        y = c(0.5, 0.5))\n  plot(x = 0:gens, \n       y = switchState,\n       type = \"o\",\n       pch = 20,\n       ylab = '',\n       xlab = \"Generation\",\n       main = \"Frequency of Task Switches\",\n       ylim = c(0, 0.2))\n  dev.off()\n  \n  for (i in 1:gens) {\n    \n    # Social State\n    socState <- t(state) %*% adj\n    socState <- t(socState)\n    \n    # Calculate proportion of neighbors in state s = 1\n    totConnect <- diag(adj %*% adj) #total connections\n    # probState <- (socState + state) / (totConnect + 1) #include self in calculation\n    probState <- socState / totConnect #include self in calculation \n    \n    # Calculate new state\n    newState <- calcNewState (probState = probState, state = state, pUpdate = probOfUpdate, thresh = thresh)\n    colorState <- colorByState(newState)\n    g_soc <- g %>% \n      set_vertex_attr(\"color\", value = colorState)\n    \n    # Quantify state of tasks\n    blue[i + 1] <- length(colorState[colorState == \"blue\"])/N\n    \n    # Quantify switches\n    switchState[i + 1] <- sum(abs(newState - state))/N\n    \n    # plot\n    path <- paste0(folderPath, \"/Gen\", i, \".jpg\")\n    png(filename = path, width = 600, height = 800, units = \"px\")\n    layout(matrix(c(1, 1, 1, 1, 1, 1, 2, 3, 4), nrow = 3, ncol = 3, byrow = TRUE))\n    plot(g_soc, \n         layout = layout, \n         vertex.label = NA,\n         vertex.size = 7,\n         vertex.color=V(g)$color)\n    hist(thresh[, 1], \n         breaks = seq(0, 1, 0.05), \n         col = rgb(0, 0, 1, 0.5),\n         ylab = NULL, \n         xlab = NULL,\n         main = \"Threshold Distribution\",\n         ylim = c(0, histLim))\n    hist(thresh[, 2],\n         breaks = seq(0, 1, 0.05), \n         col = rgb(1, 0, 0, 0.5),\n         add = TRUE)\n    plot(x = 0:gens, \n         y = c(blue, rep(NA, gens - i)), \n         pch = 20,\n         type = \"o\",\n         xlab = \"Generation\",\n         ylab = '',\n         main = \"Frequency of Task 1\",\n         ylim = c(0, 1))\n    lines(x = c(0, gens), \n          y = c(0.5, 0.5))\n    plot(x = 0:gens, \n         y = switchState,\n         type = \"o\",\n         pch = 20,\n         ylab = '',\n         xlab = \"Generation\",\n         main = \"Frequency of Task Switches\",\n         ylim = c(0, 0.35))\n    dev.off()\n    \n    # Update\n    state <- newState\n    print(paste(\"DONE: Generation \", i))\n  }\n  \n  # Resent graph parameters\n  par(mfrow = c(1, 1))\n}\n\n\n\n",
    "created" : 1487353371316.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1466709591",
    "id" : "833BFBA5",
    "lastKnownWriteTime" : 1487544868,
    "path" : "~/Documents/Research/Tarnita Lab/Evolution of DOL/Network Model/scripts/__Util_ThreshVoterFunctions.R",
    "project_path" : "scripts/__Util_ThreshVoterFunctions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}