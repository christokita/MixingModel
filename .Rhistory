X_g [,1] <- sample(c(0, 1), size = 16)
X_g [,1] <- sample(c(0, 1), replace = T, size = 16)
X_g
X_g [,2] <- sample(c(0, 1), replace = T, size = 16)
X_g
X_g[,2] <- 0
X_g
X_g * alpha
# Calculate
effective_act <- state_matrix / n
effective_act
state_matrix
state_matrix <- X_g
state_matrix
# Calculate
effective_act <- state_matrix / n
effect_act
effective_act
colSum(effective_act)
colSums(effective_act)
effective_act <- effective_act * alpha
effective_act
active_amount <- colSums(effective_act)
active_amount
stim_values
new_values <- stim_values + deltas - active_amount
new_values
active_amount-0.6
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
file_name <- "DifferentDeltas"
####################
# Set global variables
####################
# Initial paramters: Free to change
# Base parameters
Ns             <- c(4, 16) #vector of number of individuals to simulate
m              <- 2 #number of tasks
gens           <- 10000 #number of generations to run simulation
corrStep       <- 200 #number of time steps for calculation of correlation
reps           <- 1 #number of replications per simulation (for ensemble) !!Change!!
# Threshold Parameters
mixes          <- c("A", "B", "AB")
A_ThreshM      <- c(12, 8) #population threshold means for clone line A !!Change!!
A_ThreshSD     <- A_ThreshM * 0.1 #population threshold standard deviations for clone line A !!Change!!
B_ThreshM      <- c(8, 12) #population threshold means for clone line B !!Change!!
B_ThreshSD     <- B_ThreshM * 0.1 #population threshold standard deviations for clone line B !!Change!!
InitialStim    <- c(0, 0) #intital vector of stimuli
deltas         <- c(0.6, 0.6) #vector of stimuli increase rates
threshSlope    <- 7 #exponent parameter for threshold curve shape
alpha          <- m
A_alpha        <- c(m, m) #efficiency of task performance
B_alpha        <- A_alpha * 0.7
quitP          <- 0.2 #probability of quitting task once active !!Change!!
#########
####################
# Run simulation multiple times
####################
# Prep meta-lists for collection of group size simulations
groups_taskDist  <- list()
groups_taskCorr  <- list()
groups_taskStep  <- list()
groups_taskTally <- list()
groups_stim      <- list()
groups_entropy   <- list()
# Loop through group sizes
for (i in 1:length(Ns)) {
# Loop through clonals mixes
mix_taskDist <- list()
mix_taskCorr <- list()
for (mix_index in 1:length(mixes)) {
# Set mix
mix <- mixes[mix_index]
# Set stim levels (for different larvae)
# if (mix == "A") {
#   StimRates      <- c(0.6, 0.6)
# } else if (mix == "AB") {
#   StimRates      <- c(0.6, 0.6) * 1.3
# } else if (mix == "B") {
#   StimRates      <- c(0.6, 0.6) * 1.4
# }
# Set work efficiency by lines
if (mix == "A") {
alpha      <- matrix(rep(A_alpha, n), ncol = m)
} else if (mix == "AB") {
input      <- c( rep(A_alpha, n/2), rep(B_alpha, n/2) )
alpha      <- matrix(input, ncol = m, byrow = T)
} else if (mix == "B") {
alpha      <- matrix(rep(B_alpha, n), ncol = m)
}
# Set group size
n <- Ns[i]
# Prep lists for collection of simulation outputs
ens_taskDist  <- list()
ens_taskCorr  <- list()
ens_taskStep  <- list()
ens_taskTally <- list()
ens_entropy   <- list()
ens_stim      <- list()
# Run Simulations
for (sim in 1:reps) {
# Set initial probability matrix (P_g)
P_g <- initiateProbMatrix(n = n, m = m)
# Seed task (external) stimuli
stimMat <- seedStimuls(InitialSVector = InitialStim,
gens = gens)
# Seed internal thresholds
if (mix == "A") {
threshMat <- seedThresholds(n = n,
m = m,
ThresholdMeans = A_ThreshM,
ThresholdSDs = A_ThreshSD)
rownames(threshMat) <- paste0("A-", rownames(threshMat))
} else if(mix == "B") {
threshMat <- seedThresholds(n = n,
m = m,
ThresholdMeans = B_ThreshM,
ThresholdSDs = B_ThreshSD)
rownames(threshMat) <- paste0("B-", rownames(threshMat))
} else if(mix == "AB") {
threshMatA <- seedThresholds(n = n / 2,
m = m,
ThresholdMeans = A_ThreshM,
ThresholdSDs = A_ThreshSD)
rownames(threshMatA) <- paste0("A-", rownames(threshMatA))
threshMatB <- seedThresholds(n = n / 2,
m = m,
ThresholdMeans = B_ThreshM,
ThresholdSDs = B_ThreshSD)
rownames(threshMatB) <- paste0("B-", rownames(threshMatB))
threshMat <- rbind(threshMatA, threshMatB)
rm(threshMatA, threshMatB)
}
# Start task performance
X_g <- matrix(data = rep(0, length(P_g)), ncol = ncol(P_g))
# Create cumulative task performance matrix
X_tot <- X_g
# Prep correlation step matrix
X_prev <- matrix(data = rep(0, n * m), ncol = m)
X_prevTot <- matrix(data = rep(0, n * m), ncol = m)
taskCorr <- list()
taskStep <- list()
taskTally <- list()
####################
# Simulate
####################
# Run simulation
for (t in 1:gens) {
# Update stimuli
stimMat <- update_stim(stim_matrix = stimMat,
deltas = deltas,
alpha = alpha,
state_matrix = X_g,
time_step = t)
# Calculate task demand based on global stimuli
P_g <- calcThresholdProbMat(TimeStep = t + 1, # first row is generation 0
ThresholdMatrix = threshMat,
StimulusMatrix = stimMat,
nSlope = threshSlope)
# Update task performance
X_g <- updateTaskPerformance(P_sub_g    = P_g,
TaskMat    = X_g,
QuitProb   = quitP)
# Capture current task performance tally
tally <- matrix(c(t, colSums(X_g)), ncol = ncol(X_g) + 1)
colnames(tally) <- c("t", colnames(X_g))
tally <- transform(tally, Inactive = n - sum(X_g), n = n, replicate = sim)
taskTally[[t]] <- tally
# Update total task performance profile
X_tot <- X_tot + X_g
# Create time step for correlation
if (t %% corrStep == 0) {
# Get tasks performance in correlation step
X_step <- X_tot - X_prevTot
# Add to ensemble list of task steps
taskStep[[t / corrStep]] <- X_step
# Calculate rank correlation if it is not the first step
if(sum(X_prev) != 0) {
# Normalize
stepNorm <- X_step / rowSums(X_step)
prevNorm <- X_prev / rowSums(X_prev)
# Calculate ranks
step_ranks <- calculateTaskRank(TaskStepMat = X_step)
prev_ranks <- calculateTaskRank(TaskStepMat = X_prev)
# Calculate Correlation
rankCorr <- cor(prev_ranks, step_ranks, method = "spearman")
# Put in list
taskCorr[[(t / corrStep) - 1]] <- diag(rankCorr)
names(taskCorr)[(t / corrStep) - 1] <- paste0("Gen", t)
}
# Update previous step total matrix
X_prevTot <- X_tot
# Update previous step total matrix
X_prev <- X_step
}
}
# Calculate Entropy
# entropy <- mutualEntropy(TotalStateMat = X_tot)
# entropy <- transform(entropy, n = n, replicate = sim)
# Calculate total task distribution
# totalTaskDist <- X_tot / rowSums(X_tot)
totalTaskDist <- X_tot / gens
totalTaskDist <- transform(totalTaskDist, Inactive = gens - rowSums(X_tot),
n = n,
replicate = sim,
Line = rownames(threshMat),
Mix = mix)
totalTaskDist$Line <- gsub("([A-Z]).*", "\\1", totalTaskDist$Line)
# Create tasktally table
# taskTally <- do.call("rbind", taskTally)
# Create tasktally table
# stimMat <- transform(stimMat, n = n, replicate = sim)
# Add total task distributions, entropy values, and graphs to lists
ens_taskDist[[sim]]  <- totalTaskDist
ens_taskCorr[[sim]]  <- taskCorr
# ens_entropy[[sim]]   <- entropy
# ens_taskTally[[sim]] <- taskTally
# ens_taskStep[[sim]]  <- taskStep
# ens_stim[[sim]]      <- stimMat
# Print simulation completed
print(paste0("DONE: Mix = ", mix,  ", N = ", n, ", Simulation ", sim))
}
# Calculate mean correlation for each n
runCorrs <- lapply(ens_taskCorr, function(x) {
# Unlist
runs <- do.call("rbind", x)
# Calculate mean
runMean <- matrix(data = rep(NA, m), ncol =  m)
for (column in 1:m) {
runMean[ , column] <- mean(runs[ , column], na.rm = TRUE)
}
colnames(runMean) <- colnames(runs)
return(runMean)
})
runCorrs <- do.call("rbind", runCorrs)
runCorrs <- transform(runCorrs, n = n, Mix = mix)
# Add to list of lists
mix_taskDist[[mix_index]]  <- ens_taskDist
mix_taskCorr[[mix_index]]  <- runCorrs
# groups_taskStep[[i]]  <- ens_taskStep
# groups_taskTally[[i]] <- ens_taskTally
# groups_stim[[i]]      <- ens_stim
# groups_entropy[[i]]   <- ens_entropy
}
groups_taskDist[[i]]  <- mix_taskDist
groups_taskCorr[[i]]  <- mix_taskCorr
}
input      <- c( rep(A_alpha, n/2), rep(B_alpha, n/2) )
# Loop through clonals mixes
mix_taskDist <- list()
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
plot(stimMat[,1])
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/2_EvaluateResults.R', echo=TRUE)
A_alpha        <- c(1.2*m, 1.2*m) #efficiency of task performance
B_alpha        <- c(m, m)
################################################################################
#
# Model incorporating both thresholds and network dynamics
#
################################################################################
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
file_name <- "DifferentAlphas_OneTask"
####################
# Set global variables
####################
# Initial paramters: Free to change
# Base parameters
Ns             <- c(4, 16) #vector of number of individuals to simulate
m              <- 2 #number of tasks
gens           <- 10000 #number of generations to run simulation
corrStep       <- 200 #number of time steps for calculation of correlation
reps           <- 10 #number of replications per simulation (for ensemble) !!Change!!
# Threshold Parameters
mixes          <- c("A", "B", "AB")
A_ThreshM      <- c(10, 10) #population threshold means for clone line A !!Change!!
A_ThreshSD     <- A_ThreshM * 0.1 #population threshold standard deviations for clone line A !!Change!!
B_ThreshM      <- c(10, 10) #population threshold means for clone line B !!Change!!
B_ThreshSD     <- B_ThreshM * 0.1 #population threshold standard deviations for clone line B !!Change!!
InitialStim    <- c(0, 0) #intital vector of stimuli
deltas         <- c(0.6, 0.6) #vector of stimuli increase rates
threshSlope    <- 7 #exponent parameter for threshold curve shape
alpha          <- m
A_alpha        <- c(1.2*m, 1.2*m) #efficiency of task performance
B_alpha        <- c(m, m)
quitP          <- 0.2 #probability of quitting task once active !!Change!!
A_alpha
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/2_EvaluateResults.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/2_EvaluateResults.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/2_EvaluateResults.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
X_g
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
X_g
stim_matrix = stimMat
deltas = deltas
alpha = alpha
state_matrix = X_g
time_step = t
# Get preliminary info
n <- nrow(state_matrix)
stim_values <- stim_matrix[time_step, ]
stim_values
# Calculate
effective_act <- state_matrix / n
effective_act
effective_act <- effective_act * alpha
effective_act
active_amount <- colSums(effective_act)
active_amount
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/2_EvaluateResults.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/2_EvaluateResults.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_Mixing_Social.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_Mixing_Social.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_Mixing_Social.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_Mixing_Social.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_Mixing_Social.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/2_EvaluateResults.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/2_EvaluateResults.R', echo=TRUE)
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
file_name <- "AlphaDiff_OneHighOneLow"
####################
# Set global variables
####################
# Initial paramters: Free to change
# Base parameters
Ns             <- c(4, 16) #vector of number of individuals to simulate
m              <- 2 #number of tasks
gens           <- 10000 #number of generations to run simulation
corrStep       <- 200 #number of time steps for calculation of correlation
reps           <- 10 #number of replications per simulation (for ensemble) !!Change!!
# Threshold Parameters
mixes          <- c("A", "B", "AB")
A_ThreshM      <- c(14, 14) #population threshold means for clone line A !!Change!!
A_ThreshSD     <- A_ThreshM * 0.1 #population threshold standard deviations for clone line A !!Change!!
B_ThreshM      <- c(10, 10) #population threshold means for clone line B !!Change!!
B_ThreshSD     <- B_ThreshM * 0.1 #population threshold standard deviations for clone line B !!Change!!
InitialStim    <- c(0, 0) #intital vector of stimuli
deltas         <- c(0.6, 0.6) #vector of stimuli increase rates
# threshSlope    <- 7 #exponent parameter for threshold curve shape
A_threshSlope  <- 7 #exponent parameter for threshold curve shape
B_threshSlope  <- 7 #exponent parameter for threshold curve shape
alpha          <- m
A_alpha        <- c(m*1.5, m*0.5) #efficiency of task performance
B_alpha        <- c(m*0.5, m*1.5)
quitP          <- 0.2 #probability of quitting task once active !!Change!!
mix == "AB"
mix = "AB"
# Set work efficiency by lines
if (mix == "A") {
alpha      <- matrix(rep(A_alpha, n), ncol = m)
} else if (mix == "AB") {
input      <- c( rep(A_alpha, n/2), rep(B_alpha, n/2) )
alpha      <- matrix(input, ncol = m, byrow = T)
} else if (mix == "B") {
alpha      <- matrix(rep(B_alpha, n), ncol = m)
}
# Seed Etas (threshold slopes) by lines
if (mix == "A") {
thresh_slope_mat <- data.frame(Eta = rep(A_threshSlope, n))
} else if(mix == "B") {
thresh_slope_mat <- data.frame(Eta = rep(B_threshSlope, n))
} else if(mix == "AB") {
thresh_slope_mat <- data.frame(Eta = c(rep(A_threshSlope, n/2), rep(B_threshSlope, n/2)))
rm(threshMatA, threshMatB)
}
n =14
# Set work efficiency by lines
if (mix == "A") {
alpha      <- matrix(rep(A_alpha, n), ncol = m)
} else if (mix == "AB") {
input      <- c( rep(A_alpha, n/2), rep(B_alpha, n/2) )
alpha      <- matrix(input, ncol = m, byrow = T)
} else if (mix == "B") {
alpha      <- matrix(rep(B_alpha, n), ncol = m)
}
# Seed Etas (threshold slopes) by lines
if (mix == "A") {
thresh_slope_mat <- data.frame(Eta = rep(A_threshSlope, n))
} else if(mix == "B") {
thresh_slope_mat <- data.frame(Eta = rep(B_threshSlope, n))
} else if(mix == "AB") {
thresh_slope_mat <- data.frame(Eta = c(rep(A_threshSlope, n/2), rep(B_threshSlope, n/2)))
rm(threshMatA, threshMatB)
}
if (mix == "A") {
alpha      <- matrix(rep(A_alpha, n), ncol = m)
} else if (mix == "AB") {
input      <- c( rep(A_alpha, n/2), rep(B_alpha, n/2) )
alpha      <- matrix(input, ncol = m, byrow = T)
} else if (mix == "B") {
alpha      <- matrix(rep(B_alpha, n), ncol = m)
}
# Seed Etas (threshold slopes) by lines
if (mix == "A") {
thresh_slope_mat <- data.frame(Eta = rep(A_threshSlope, n))
} else if(mix == "B") {
thresh_slope_mat <- data.frame(Eta = rep(B_threshSlope, n))
} else if(mix == "AB") {
thresh_slope_mat <- data.frame(Eta = c(rep(A_threshSlope, n/2), rep(B_threshSlope, n/2)))
}
thresh_slope_mat
TimeStep = 1
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
TimeStep = t + 1
ThresholdMatrix = threshMat
StimulusMatrix = stimMat
nSlopeMatrix = thresh_slope_mat
stimulusThisStep <- StimulusMatrix[TimeStep, ]
stimuousThisStep
stimulusThisStep
i = 1
# select row for individual in threshold matrix
indThresh <- ThresholdMatrix[i, ]
# create task vector to be output and bound
taskThresh <- rep(NA, length(indThresh))
# loop through each task within individual
for (j in 1:length(taskThresh)) {
taskThresh[j] <- threshProb(s = stimulusThisStep[j], phi = indThresh[j], nSlope = nSlopeMatrix[i])
}
# select proper stimulus for this time step
stimulusThisStep <- StimulusMatrix[TimeStep, ]
# calculate threshold probabilities for one individual
thresholdP <- lapply(1:nrow(ThresholdMatrix), function(i) {
# select row for individual in threshold matrix
indThresh <- ThresholdMatrix[i, ]
# create task vector to be output and bound
taskThresh <- rep(NA, length(indThresh))
# loop through each task within individual
for (j in 1:length(taskThresh)) {
taskThresh[j] <- threshProb(s = stimulusThisStep[j], phi = indThresh[j], nSlope = nSlopeMatrix[i])
}
return(taskThresh)
})
# calculate threshold probabilities for one individual
thresholdP <- lapply(1:nrow(ThresholdMatrix), function(i) {
# select row for individual in threshold matrix
indThresh <- ThresholdMatrix[i, ]
# create task vector to be output and bound
taskThresh <- rep(NA, length(indThresh))
# Get eta
eta <- nSlopeMatrix[i]
# loop through each task within individual
for (j in 1:length(taskThresh)) {
taskThresh[j] <- threshProb(s = stimulusThisStep[j], phi = indThresh[j], nSlope = eta)
}
return(taskThresh)
})
nSlopeMatrix
thresh_slope_mat
thresh_slope_mat[1]
# Get eta
eta <- nSlopeMatrix[i, 1]
# calculate threshold probabilities for one individual
thresholdP <- lapply(1:nrow(ThresholdMatrix), function(i) {
# select row for individual in threshold matrix
indThresh <- ThresholdMatrix[i, ]
# create task vector to be output and bound
taskThresh <- rep(NA, length(indThresh))
# Get eta
eta <- nSlopeMatrix[i, 1]
# loop through each task within individual
for (j in 1:length(taskThresh)) {
taskThresh[j] <- threshProb(s = stimulusThisStep[j], phi = indThresh[j], nSlope = eta)
}
return(taskThresh)
})
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_MixingTest.R', echo=TRUE)
rm(list = ls())
source("scripts/util/__Util__MASTER.R")
load("output/Rdata/Diff_Etas_HighB.Rdata")
file_name <- "Diff_Etas_HighB"
####################
# Final task distributions
####################
# Prepare
task_dist <- task_dist %>%
group_by(n) %>%
mutate(set = paste0(Mix, "-", replicate)) %>%
mutate(set = factor(set,
levels = c(paste("A", unique(replicate), sep = "-"),
paste("B", unique(replicate), sep = "-"),
paste("AB", unique(replicate), sep = "-")) ))
# Plot
gg_dist <- ggplot(data = task_dist, aes(y = Task1, x = set, color = Line)) +
geom_point(size = 0.3) +
theme_classic() +
labs(x = "Replicate",
y = "Frequency Task 1") +
#scale_color_brewer(palette = "Paired") +
scale_color_manual(values = c("#ca0020", "#0571b0")) +
scale_y_continuous(limits = c(0, 1), breaks = seq(0, 1, 0.2)) +
theme_ctokita() +
theme(axis.text.x = element_blank(),
strip.background = element_rect(color = NA, fill = "grey85")) +
facet_grid(n~.)
gg_dist
ggsave(filename = paste0("output/Task_dist/", file_name, ".png"), width = 3, height = 3, dpi = 400)
source('~/Documents/Research/Tarnita Lab/Mixing Experiments/MixingModel/scripts/1_Mixing_Social.R', echo=TRUE)
